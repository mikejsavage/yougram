package main

import "encoding/hex"
import "fmt"
import "mikegram/sqlc"

templ photogrid( photos []Photo, asset_base_url string, thumbnail_base_url string ) {
	<script>
	function MakeThumbhash( img, thumbhash ) {
		let raw_thumbhash = atob( thumbhash );
		let u8_thumbhash = new Uint8Array( raw_thumbhash.length );
		for( let i = 0; i < raw_thumbhash.length; i++ ) {
			u8_thumbhash[ i ] = raw_thumbhash.charCodeAt( i );
		}
		img.src = thumbHashToDataURL( u8_thumbhash );
	}

	document.addEventListener( "alpine:init", () => {
		Alpine.data( "photos", () => ( {
			photos: {{ photos }},
			fullscreen: null,
			base_year: 2014,
			year_transitions: [ 0.1, 0.3, 0.5, 0.6, 0.9 ],
			height: 0,
			top: 0,
			visible_range: [ 0, 0 ],

			StripPx( size ) {
				return size.replace( /px$/, "" );
			},

			GridSpec() {
				let cols = window.getComputedStyle( document.querySelector( ".grid" ) )[ "grid-template-columns" ].split( " " );
				let gap = window.getComputedStyle( document.querySelector( ".grid" ) )[ "gap" ];
				return {
					cols: cols.length,
					row_height: parseFloat( this.StripPx( cols[ 0 ] ) ),
					gap: parseFloat( this.StripPx( gap ) ),
				};
			},

			UpdateLayout() {
				// TODO: account for grid pos on page
				let grid = this.GridSpec();

				let top = window.visualViewport.pageTop - window.visualViewport.height * 0.5;
				let bottom = window.visualViewport.pageTop + window.visualViewport.height * 1.5;

				let row_height = parseFloat( grid.row_height ) + parseFloat( grid.gap );

				let last_row = Math.ceil( this.photos.length / grid.cols );
				let top_row = Math.max( 0, Math.min( last_row, Math.floor( top / row_height ) ) );
				let bottom_row = Math.min( last_row, Math.ceil( bottom / row_height ) );

				this.visible_range = [
					Math.min( this.photos.length, top_row * grid.cols ),
					Math.min( this.photos.length, bottom_row * grid.cols ),
				];

				this.height = ( grid.row_height * last_row + grid.gap * Math.max( 0, last_row - 1 ) ) + "px";
				this.top = ( grid.row_height * top_row + grid.gap * Math.max( 0, top_row - 1 ) ) + "px";
			},
		} ) );
	} );
	</script>

	<div x-data="photos"
		:style="{ height: height }"
		x-init="UpdateLayout()"
		@scroll.window="UpdateLayout()"
		@resize.window="UpdateLayout()"
	>
		<style>
		@scope {
			.grid {
				position: relative;
				display: grid;
				grid-template-columns: repeat( auto-fill, minmax( 6cm, 1fr ) );
				gap: 0.2rem;
				padding: 0.5rem;
			}

			@media (max-width: 479px) {
				.grid {
					padding: 0;
				}
			}

			.thumbnail img {
				aspect-ratio: 1;
				width: 100%;
				object-fit: cover;
				object-position: 50% 50%;
			}

			.fullscreen {
				background: rgba( 26, 26, 26, 0.9 );
				position: fixed;
				top: 0;
				left: 0;
				z-index: var( --fullscreen-z );
				width: 100vw;
				height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
			}

			.fullscreen img {
				width: 100vw;
				max-height: 100vh;
				object-fit: contain;
				/* padding: 2.5vmax; */
				user-select: none;
			}

			.stack {
				display: grid;
			}

			.stack > * {
				grid-row: 1;
				grid-column: 1;
			}

			.settings {
				color: white;
				opacity: 0.2;
				position: fixed;
				top: 2vh;
				right: 2vh;
				transition: opacity 250ms linear;
				transition-delay: 1s;
			}

			.settings:hover {
				opacity: 1;
				transition: none;
			}
		}
		</style>

		<template x-if="fullscreen != null">
			<div class="fullscreen"
				@click="fullscreen = null"
				@keydown.window.escape="fullscreen = null"
				@keydown.window.left="fullscreen = Math.max( 0, fullscreen - 1 )"
				@keydown.window.right="fullscreen = Math.min( photos.length - 1, fullscreen + 1 )"
			>
				<div class="stack">
					<img x-init="MakeThumbhash( $el, photos[ fullscreen ].thumbhash )">
					<img :src={ fmt.Sprintf( "'%s' + photos[ fullscreen ].asset", thumbnail_base_url ) } onload="this.previousElementSibling.remove()" @error="$el.remove()">
					<img :src={ fmt.Sprintf( "'%s' + photos[ fullscreen ].asset", asset_base_url ) } onload="this.previousElementSibling.remove()" @error="$el.remove()">
				</div>

				<div class="settings">[cog] [bin]</div>
			</div>
		</template>

		<div class="grid" :style="{ top: top }">
			<template x-for="i in visible_range[ 1 ] - visible_range[ 0 ]">
				<a class="thumbnail stack" :href="'/Special:asset/' + photos[ visible_range[ 0 ] + i - 1 ].asset" @click.prevent="fullscreen = visible_range[ 0 ] + i - 1">
					<img x-init="MakeThumbhash( $el, photos[ visible_range[ 0 ] + i - 1 ].thumbhash )">
					<img :src={ fmt.Sprintf( "'%s' + photos[ visible_range[ 0 ] + i - 1 ].asset", thumbnail_base_url ) } loading="lazy" onload="this.previousElementSibling.remove()" @error="$el.remove()">
				</a>
			</template>
		</div>
	</div>
}

type AlbumOwnership int
const (
	AlbumOwnership_Owned AlbumOwnership = iota
	AlbumOwnership_SharedWithMe
	AlbumOwnership_Guest
)

templ albumSettings( album sqlc.GetAlbumByURLRow ) {
	<div x-data="{
		show: false,
		name: '',
		url: '',
		auto_slug: true,
	}">
		<button @click="show = true; $el.parentElement.querySelector( 'form' ).reset()">Album settings</button>

		<div class="dropdown"
			x-cloak x-show="show"
			@click.away="show = false"
			@keydown.window.escape="show = false"
		>
			<form
				style="display: flex; flex-direction: column; width: 25rem"
				hx-post="/Special:albumSettings"
				hx-target="find .error"
				hx-swap="textContent"
				hx-disabled-elt="find button"
				hx-on::before-request="htmx.find('#error').innerText = ''"
			>
				<h2>Album Settings</h2>

				<input type="hidden" name="album_id" value={ album.ID }>

				<b>Name</b>
				<input type="text" name="name" x-model="name" value={ album.Name } autocomplete="off">

				<div>
					<b>URL</b>
					<label>
						<input type="checkbox" x-model="auto_slug" checked> Auto
					</label>
				</div>

				<input type="text" name="url" x-model="url" value={ album.UrlSlug } autocomplete="off" x-effect="if( auto_slug ) { url = MakeSlug( name ); }" :readonly="auto_slug">

				<button type="submit" style="width: min-content">Save</button>

				<div class="error"></div>
			</form>
		</div>
	</div>
}

templ shareButton( album sqlc.GetAlbumByURLRow, ownership AlbumOwnership ) {
	<div
		x-data={ templ.JSONString( map[string]any {
			"show_dialog": false,
			"sharing": album.Shared,
			"readonly_secret": album.ReadonlySecret,
			"readwrite_secret": album.ReadwriteSecret,
		} ) }

		@album:start_sharing.window="sharing = true"
		@album:stop_sharing.window="sharing = false"
	>
		<button @click="show_dialog = true">
			<span :style="{ color: sharing ? 'var(--green)' : 'var(--red)' }">&#9679;</span>
			Share
		</button>

		<div class="dropdown"
			x-cloak x-show="show_dialog"
			@click.away="show_dialog = false"
			@keydown.window.escape="show_dialog = false"
		>
			<form style="width: 15rem">
				<h2>Sharing</h2>
				if ownership == AlbumOwnership_Owned {
					<button style="margin-block: 0.5rem"
						x-text="sharing ? 'Disable sharing' : 'Enable sharing'"
						hx-post="/Special:shareAlbum"
						hx-disabled-elt="this"
					/><br>
					<input type="hidden" name="album_id" value={ album.ID }>
					<input type="hidden" name="share" :value="sharing ? 0 : 1">
				}
				<a href={ templ.URL( guest_url + "/" + album.UrlSlug + "/" + album.ReadonlySecret ) }>Read-only guest link</a><br>
				<a href={ templ.URL( guest_url + "/" + album.UrlSlug + "/" + album.ReadwriteSecret ) }>Read-write guest link</a>
			</form>
		</div>
	</div>
}

templ selectButton() {
	<button style="display: flex; align-items: center; gap: 0.25rem">
		<input type="checkbox" class="no-mobile" style="pointer-events: none; margin: 0">
		Select
	</button>
}

templ downloadButton( album sqlc.GetAlbumByURLRow, ownership AlbumOwnership ) {
	<div x-data="{
		show_download_dialog: false,
		include: null,
		variants: null,
		heic_as_jpg: null,
	}">
		<button @click="show_download_dialog = true; $el.parentElement.querySelector( 'form' ).reset()">
			Download
		</button>

		<div class="dropdown"
			x-cloak x-show="show_download_dialog"
			@click.away="show_download_dialog = false"
			@keydown.window.escape="show_download_dialog = false"
		>
			{{
				action := sel( ownership != AlbumOwnership_Guest,
					"/Special:download/" + templ.URL( album.UrlSlug ),
					templ.URL( fmt.Sprintf( "/%s/%s/download", album.UrlSlug, album.ReadonlySecret ) ),
				)
			}}

			<form method="GET" action={ action }>
				<h2>Download { album.Name }</h2>

				<div style="display: grid; grid-template-columns: auto auto; column-gap: 1rem">
					// <b>Include</b>
					// <div>
					// 	<label>
					// 		<input type="radio" name="include" x-model="include" value="all">
					// 		All photos
					// 	</label>
					// 	<label>
					// 		<input type="radio" name="include" x-model="include" value="selected">
					// 		Only selected
					// 	</label>
					// </div>

					<b>Variants</b>
					<div style="display: flex; gap: 1rem">
						<label>
							<input type="radio" name="variants" x-model="variants" value="key_only" checked>
							Key photos only
						</label>
						<label>
							<input type="radio" name="variants" x-model="variants" value="key_and_raw">
							Key + RAW
						</label>
						<label>
							<input type="radio" name="variants" x-model="variants" value="everything">
							Everything
						</label>
					</div>

					<b>Formats</b>
					<fieldset :disabled="variants == 'everything'">
						<label>
							<input type="checkbox" name="heic_as_jpeg" x-model="heic_as_jpg" checked>
							Download HEIC as JPEG
						</label>
					</fieldset>
				</div>

				<button type="submit" style="margin-top: 0.5rem">Download</button>
			</form>
		</div>
	</div>
}

templ uploadButton() {
	<script>
	function MakeUploadForm() {
		return {
			files: [ ],

			Upload( idx ) {
				if( idx >= this.files.length ) {
					return;
				}

				const xhr = new XMLHttpRequest();
				xhr.open( "PUT", window.location.pathname, true );
				xhr.upload.onprogress = e => this.files[ idx ].progress = e.loaded / e.total;
				xhr.onload = () => {
					this.files[ idx ].progress = 1;
					this.Upload( idx + 1 );
				};

				let data = new FormData();
				data.append( "assets", this.files[ idx ].file );

				xhr.send( data );

				this.files[ idx ].xhr = xhr;
			},

			async Changed( e ) {
				let first_new = this.files.length;
				this.totoa

				for( const file of e.target.files ) {
					let promise = new Promise( function( resolve ) {
						let reader = new FileReader();
						reader.onload = function( e ) {
							resolve( e.target.result );
						};
						reader.readAsDataURL( file );
					} );

					this.files.push( {
						file: file,
						name: file.name,
						thumbnail: await promise,
						progress: 0,
					} );
				}

				this.Upload( first_new );
			},

			Cancel( idx ) {
			},
		};
	}
	</script>

	<div x-data="MakeUploadForm()">
		<style>
		@scope {
			img {
				aspect-ratio: 1;
				width: 2rem;
				object-fit: cover;
				object-position: 50% 50%;
				vertical-align: middle;
				margin: 0.25rem 0;
			}
		}
		</style>

		<button type="button">
			<label>
				Upload
				<input type="file" name="photos" multiple @change="Changed" style="display: none">
			</label>
		</button>

		<div class="dropdown" x-cloak x-show="files.length > 0">
			<div style="max-height: 50vh; overflow-y: scroll">
				<template x-for="(file, i) in files">
					<div>
						<!-- <img :src="file.thumbnail"> -->
						<span x-text="Math.floor( file.progress * 100 )"></span>%
						<span x-text="file.name"></span>
					</div>
				</template>
			</div>
		</div>
	</div>
}

templ albumTemplate( album sqlc.GetAlbumByURLRow, photos []Photo, ownership AlbumOwnership, can_upload bool ) {
	<style>
	/* see https://www.w3schools.com/Css/css_dropdowns.asp */
	.dropdown {
		position: relative;
	}

	.dropdown > * {
		position: absolute;
		top: 1rem;
		right: 0;
		z-index: var( --modal-z );
		width: max-content;
		padding: 0.5rem;
		background: #fff;
		border: 4px solid #333;
		box-shadow: 0 0 10px #666;
	}
	</style>

	<main x-data="{ selected: new Map(), last_selected: null }">
		<aside>
			<style>
			@scope {
				:scope {
					position: sticky;
					top: 0;
					z-index: var( --sticky-z );
					padding: 0.5rem;
					background: white;
					border-bottom: 1px solid #ccc;
					display: flex;
					flex-direction: row;
					align-items: center;
					gap: 0;
				}

				.left {
					display: flex;
					flex-direction: column;
				}

				.right {
					display: flex;
					flex-direction: row;
					align-items: center;
					gap: 1rem;
				}

				.right > div {
					line-height: 1;
				}

				@media (max-width: 479px) {
					:scope {
						background: rgba( 0, 0, 0, 0.2 );linear-gradient( rgba( 0, 0, 0, 0.2 ) 80%, transparent );
						box-shadow: 0 0.5rem 0.5rem rgba( 0, 0, 0, 0.2 );
						border: 0;
					}

					h1 {
						color: #fff;
						font-size: 1rem;
					}

					.no-mobile {
						display: none !important;
					}

					.right {
						gap: 0.5rem;
					}
				}
			}
			</style>

			<div class="left">
				<h1>{ album.Name }</h1>
				<span style="font-size: 80%" class="no-mobile">
					if ownership != AlbumOwnership_Owned {
						<span>{ album.OwnerUsername }'s album</span>
					}

					<span>Oct 2023 &ndash; Jan 2025</span>
					<span>{ len( photos ) } { sel( len( photos ) == 1, "photo", "photos" ) }</span>
				</span>
			</div>

			<div style="flex-grow: 1"></div>

			<div class="right">
					if ownership == AlbumOwnership_Owned {
						@albumSettings( album )
					}

					if ownership != AlbumOwnership_Guest {
						@shareButton( album, ownership )
					}

					@downloadButton( album, ownership )
					if can_upload {
						@uploadButton()
					}

					@selectButton()
			</div>
		</aside>

		if can_upload && ownership == AlbumOwnership_Guest {
			<b>
				This page lets you add and remove photos so don't share it with randoms, give them
				<a href={ templ.URL( guest_url + "/" + album.UrlSlug + "/" + album.ReadonlySecret ) }>this read only link</a>
				instead!!
			</b>
		}

		<noscript>
			<div style="padding: 0.5rem">Sorry but nothing works without Javascript</div>
		</noscript>

		{{ asset_base_url := "/Special:asset/" }}
		{{ thumbnail_base_url := "/Special:thumbnail/" }}
		if ownership == AlbumOwnership_Guest {
			{{ asset_base_url = fmt.Sprintf( "/%s/%s/asset/", album.UrlSlug, sel( can_upload, album.ReadwriteSecret, album.ReadonlySecret ) ) }}
			{{ thumbnail_base_url = fmt.Sprintf( "/%s/%s/thumbnail/", album.UrlSlug, sel( can_upload, album.ReadwriteSecret, album.ReadonlySecret ) ) }}
		}

		@photogrid( photos, asset_base_url, thumbnail_base_url )
	</main>
}

templ ownedAlbumTemplate( album sqlc.GetAlbumByURLRow, photos []Photo ) {
	@albumTemplate( album, photos, AlbumOwnership_Owned, true )
}

templ sharedAlbumTemplate( album sqlc.GetAlbumByURLRow, photos []Photo ) {
	@albumTemplate( album, photos, AlbumOwnership_SharedWithMe, true )
}

templ guestAlbumTemplate( album sqlc.GetAlbumByURLRow, photos []Photo, can_upload bool ) {
	<meta property="og:title" content={ album.Name }>
	<meta property="og:image" content={ fmt.Sprintf( "%s/%s/%s/thumbnail/%s", guest_url, album.UrlSlug, album.ReadonlySecret, hex.EncodeToString( album.KeyPhotoSha256 ) ) }>
	@albumTemplate( album, photos, AlbumOwnership_Guest, can_upload )
}
