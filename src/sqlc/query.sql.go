// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addAssetToPhoto = `-- name: AddAssetToPhoto :exec
INSERT INTO photo_assets ( photo_id, asset_id ) VALUES ( ?, ? )
`

type AddAssetToPhotoParams struct {
	PhotoID int64
	AssetID int64
}

func (q *Queries) AddAssetToPhoto(ctx context.Context, arg AddAssetToPhotoParams) error {
	_, err := q.db.ExecContext(ctx, addAssetToPhoto, arg.PhotoID, arg.AssetID)
	return err
}

const addPhotoToAlbum = `-- name: AddPhotoToAlbum :exec
INSERT OR IGNORE INTO album_photos ( album_id, photo_id ) VALUES ( ?, ? )
`

type AddPhotoToAlbumParams struct {
	AlbumID int64
	PhotoID int64
}

func (q *Queries) AddPhotoToAlbum(ctx context.Context, arg AddPhotoToAlbumParams) error {
	_, err := q.db.ExecContext(ctx, addPhotoToAlbum, arg.AlbumID, arg.PhotoID)
	return err
}

const changePassword = `-- name: ChangePassword :exec
UPDATE users SET password = ?, cookie = ? WHERE username = username
`

type ChangePasswordParams struct {
	Password string
	Cookie   string
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.ExecContext(ctx, changePassword, arg.Password, arg.Cookie)
	return err
}

const createAlbum = `-- name: CreateAlbum :exec

INSERT INTO albums (
	owner, name, url_slug,
	shared, readonly_secret, readwrite_secret,
	autoassign_start_date, autoassign_end_date, autoassign_latitude, autoassign_longitude, autoassign_radius
) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateAlbumParams struct {
	Owner               int64
	Name                string
	UrlSlug             string
	Shared              int64
	ReadonlySecret      string
	ReadwriteSecret     string
	AutoassignStartDate sql.NullInt64
	AutoassignEndDate   sql.NullInt64
	AutoassignLatitude  sql.NullFloat64
	AutoassignLongitude sql.NullFloat64
	AutoassignRadius    sql.NullFloat64
}

// ----------
// ALBUMS --
// ----------
func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) error {
	_, err := q.db.ExecContext(ctx, createAlbum,
		arg.Owner,
		arg.Name,
		arg.UrlSlug,
		arg.Shared,
		arg.ReadonlySecret,
		arg.ReadwriteSecret,
		arg.AutoassignStartDate,
		arg.AutoassignEndDate,
		arg.AutoassignLatitude,
		arg.AutoassignLongitude,
		arg.AutoassignRadius,
	)
	return err
}

const createAsset = `-- name: CreateAsset :one

INSERT OR IGNORE INTO assets ( sha256, created_at, original_filename, type, description, date_taken, latitude, longitude )
VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )
RETURNING id
`

type CreateAssetParams struct {
	Sha256           []byte
	CreatedAt        int64
	OriginalFilename string
	Type             string
	Description      sql.NullString
	DateTaken        sql.NullInt64
	Latitude         sql.NullFloat64
	Longitude        sql.NullFloat64
}

// ----------
// ASSETS --
// ----------
func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAsset,
		arg.Sha256,
		arg.CreatedAt,
		arg.OriginalFilename,
		arg.Type,
		arg.Description,
		arg.DateTaken,
		arg.Latitude,
		arg.Longitude,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPhoto = `-- name: CreatePhoto :one

INSERT INTO photos ( owner, created_at, primary_asset, thumbnail, thumbhash, date_taken, latitude, longitude )
VALUES( ?, ?, ?, ?, ?, ?, ?, ? )
RETURNING id
`

type CreatePhotoParams struct {
	Owner        sql.NullInt64
	CreatedAt    int64
	PrimaryAsset int64
	Thumbnail    []byte
	Thumbhash    []byte
	DateTaken    sql.NullInt64
	Latitude     sql.NullFloat64
	Longitude    sql.NullFloat64
}

// ----------
// PHOTOS --
// ----------
func (q *Queries) CreatePhoto(ctx context.Context, arg CreatePhotoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createPhoto,
		arg.Owner,
		arg.CreatedAt,
		arg.PrimaryAsset,
		arg.Thumbnail,
		arg.Thumbhash,
		arg.DateTaken,
		arg.Latitude,
		arg.Longitude,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :exec

INSERT INTO users ( username, password, needs_to_reset_password, cookie ) VALUES ( ?, ?, 1, ? )
`

type CreateUserParams struct {
	Username string
	Password string
	Cookie   string
}

// ---------
// USERS --
// ---------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.Username, arg.Password, arg.Cookie)
	return err
}

const getAlbumAutoassignRules = `-- name: GetAlbumAutoassignRules :many
SELECT
	id AS album_id,
	autoassign_start_date AS start_date,
	autoassign_end_date AS end_date,
	autoassign_latitude AS latitude,
	autoassign_longitude AS longitude,
	autoassign_radius AS radius
FROM albums WHERE ? BETWEEN autoassign_start_date AND autoassign_end_date
`

type GetAlbumAutoassignRulesRow struct {
	AlbumID   int64
	StartDate sql.NullInt64
	EndDate   sql.NullInt64
	Latitude  sql.NullFloat64
	Longitude sql.NullFloat64
	Radius    sql.NullFloat64
}

func (q *Queries) GetAlbumAutoassignRules(ctx context.Context) ([]GetAlbumAutoassignRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumAutoassignRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumAutoassignRulesRow
	for rows.Next() {
		var i GetAlbumAutoassignRulesRow
		if err := rows.Scan(
			&i.AlbumID,
			&i.StartDate,
			&i.EndDate,
			&i.Latitude,
			&i.Longitude,
			&i.Radius,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumByURL = `-- name: GetAlbumByURL :one
SELECT id, owner, name, shared, readonly_secret, readwrite_secret FROM albums WHERE url_slug = ?
`

type GetAlbumByURLRow struct {
	ID              int64
	Owner           int64
	Name            string
	Shared          int64
	ReadonlySecret  string
	ReadwriteSecret string
}

func (q *Queries) GetAlbumByURL(ctx context.Context, urlSlug string) (GetAlbumByURLRow, error) {
	row := q.db.QueryRowContext(ctx, getAlbumByURL, urlSlug)
	var i GetAlbumByURLRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.Shared,
		&i.ReadonlySecret,
		&i.ReadwriteSecret,
	)
	return i, err
}

const getAlbumOwner = `-- name: GetAlbumOwner :one
SELECT owner FROM albums WHERE id = ?
`

func (q *Queries) GetAlbumOwner(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAlbumOwner, id)
	var owner int64
	err := row.Scan(&owner)
	return owner, err
}

const getAlbumOwnerByID = `-- name: GetAlbumOwnerByID :one
SELECT owner, shared FROM albums WHERE id = ?
`

type GetAlbumOwnerByIDRow struct {
	Owner  int64
	Shared int64
}

func (q *Queries) GetAlbumOwnerByID(ctx context.Context, id int64) (GetAlbumOwnerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAlbumOwnerByID, id)
	var i GetAlbumOwnerByIDRow
	err := row.Scan(&i.Owner, &i.Shared)
	return i, err
}

const getAlbumPhotos = `-- name: GetAlbumPhotos :many
SELECT photos.id, photos.thumbhash
FROM photos, album_photos
WHERE album_photos.album_id = ? AND album_photos.photo_id = photos.id
ORDER BY photos.date_taken ASC
`

type GetAlbumPhotosRow struct {
	ID        int64
	Thumbhash []byte
}

func (q *Queries) GetAlbumPhotos(ctx context.Context, albumID int64) ([]GetAlbumPhotosRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumPhotos, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumPhotosRow
	for rows.Next() {
		var i GetAlbumPhotosRow
		if err := rows.Scan(&i.ID, &i.Thumbhash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumsForUser = `-- name: GetAlbumsForUser :many
SELECT albums.name, albums.url_slug, assets.sha256 AS key_photo_sha256 FROM albums
LEFT OUTER JOIN photos ON photos.id = IFNULL( albums.key_photo, (
	SELECT photo_id FROM album_photos
	INNER JOIN photos ON photos.id = album_photos.photo_id
	WHERE album_photos.album_id = albums.id
	ORDER BY photos.date_taken DESC LIMIT 1
) )
LEFT OUTER JOIN assets ON assets.id = IFNULL( photos.primary_asset, (
	SELECT asset_id FROM photo_assets
	INNER JOIN assets AS lol ON lol.id = photo_assets.asset_id
	WHERE photo_assets.photo_id = photos.id AND lol.type != "raw"
	ORDER BY lol.created_at DESC LIMIT 1
) )
WHERE ( albums.shared OR albums.owner = ? )
ORDER BY albums.name
`

type GetAlbumsForUserRow struct {
	Name           string
	UrlSlug        string
	KeyPhotoSha256 []byte
}

func (q *Queries) GetAlbumsForUser(ctx context.Context, owner int64) ([]GetAlbumsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumsForUser, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumsForUserRow
	for rows.Next() {
		var i GetAlbumsForUserRow
		if err := rows.Scan(&i.Name, &i.UrlSlug, &i.KeyPhotoSha256); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetPhotos = `-- name: GetAssetPhotos :many
SELECT photos.id FROM photos, photo_assets
WHERE photo_assets.asset_id = ? AND photos.owner = ? AND photos.id = photo_assets.photo_id
`

type GetAssetPhotosParams struct {
	AssetID int64
	Owner   sql.NullInt64
}

func (q *Queries) GetAssetPhotos(ctx context.Context, arg GetAssetPhotosParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getAssetPhotos, arg.AssetID, arg.Owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhoto = `-- name: GetPhoto :one
SELECT assets.sha256, assets.type, assets.original_filename FROM photos, assets
WHERE photos.id = ? AND assets.id = IFNULL( photos.primary_asset,
	( SELECT id FROM assets
	INNER JOIN photo_assets ON photo_assets.asset_id = assets.id
	WHERE photo_assets.photo_id = photos.id AND assets.type != "raw"
	ORDER BY assets.created_at DESC LIMIT 1 ) )
`

type GetPhotoRow struct {
	Sha256           []byte
	Type             string
	OriginalFilename string
}

func (q *Queries) GetPhoto(ctx context.Context, id int64) (GetPhotoRow, error) {
	row := q.db.QueryRowContext(ctx, getPhoto, id)
	var i GetPhotoRow
	err := row.Scan(&i.Sha256, &i.Type, &i.OriginalFilename)
	return i, err
}

const getThumbnail = `-- name: GetThumbnail :one
SELECT thumbnail FROM photos WHERE id = ?
`

func (q *Queries) GetThumbnail(ctx context.Context, id int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getThumbnail, id)
	var thumbnail []byte
	err := row.Scan(&thumbnail)
	return thumbnail, err
}

const getUserAuthDetails = `-- name: GetUserAuthDetails :one
SELECT id, password, needs_to_reset_password, cookie FROM users WHERE username = ?
`

type GetUserAuthDetailsRow struct {
	ID                   int64
	Password             string
	NeedsToResetPassword int64
	Cookie               string
}

func (q *Queries) GetUserAuthDetails(ctx context.Context, username string) (GetUserAuthDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthDetails, username)
	var i GetUserAuthDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Password,
		&i.NeedsToResetPassword,
		&i.Cookie,
	)
	return i, err
}

const resetPassword = `-- name: ResetPassword :exec
UPDATE users SET password = ?, needs_to_reset_password = 1, cookie = ? WHERE username = username
`

type ResetPasswordParams struct {
	Password string
	Cookie   string
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) error {
	_, err := q.db.ExecContext(ctx, resetPassword, arg.Password, arg.Cookie)
	return err
}

const setAlbumIsShared = `-- name: SetAlbumIsShared :exec
UPDATE albums SET shared = ? WHERE id = ?
`

type SetAlbumIsSharedParams struct {
	Shared int64
	ID     int64
}

func (q *Queries) SetAlbumIsShared(ctx context.Context, arg SetAlbumIsSharedParams) error {
	_, err := q.db.ExecContext(ctx, setAlbumIsShared, arg.Shared, arg.ID)
	return err
}
