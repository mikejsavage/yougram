// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addAssetToPhoto = `-- name: AddAssetToPhoto :exec
INSERT OR IGNORE INTO photo_asset ( photo_id, asset_id ) VALUES ( ?, ? )
`

type AddAssetToPhotoParams struct {
	PhotoID int64
	AssetID []byte
}

func (q *Queries) AddAssetToPhoto(ctx context.Context, arg AddAssetToPhotoParams) error {
	_, err := q.db.ExecContext(ctx, addAssetToPhoto, arg.PhotoID, arg.AssetID)
	return err
}

const addAvatar = `-- name: AddAvatar :exec
INSERT OR IGNORE INTO avatar ( sha256, avatar ) VALUES ( ?, ? )
`

type AddAvatarParams struct {
	Sha256 []byte
	Avatar []byte
}

func (q *Queries) AddAvatar(ctx context.Context, arg AddAvatarParams) error {
	_, err := q.db.ExecContext(ctx, addAvatar, arg.Sha256, arg.Avatar)
	return err
}

const addPhotoToAlbum = `-- name: AddPhotoToAlbum :exec
INSERT OR IGNORE INTO album_photo ( album_id, photo_id ) VALUES ( ?, ? )
`

type AddPhotoToAlbumParams struct {
	AlbumID int64
	PhotoID int64
}

func (q *Queries) AddPhotoToAlbum(ctx context.Context, arg AddPhotoToAlbumParams) error {
	_, err := q.db.ExecContext(ctx, addPhotoToAlbum, arg.AlbumID, arg.PhotoID)
	return err
}

const areThereAnyUsers = `-- name: AreThereAnyUsers :one
SELECT EXISTS( SELECT 1 FROM user LIMIT 1 )
`

func (q *Queries) AreThereAnyUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, areThereAnyUsers)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const assetExists = `-- name: AssetExists :one

SELECT EXISTS( SELECT 1 FROM asset WHERE sha256 = ? )
`

// ----------
// ASSETS --
// ----------
func (q *Queries) AssetExists(ctx context.Context, sha256 []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, assetExists, sha256)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createAlbum = `-- name: CreateAlbum :exec

INSERT INTO album (
	owner, name, url_slug,
	shared, readonly_secret, readwrite_secret, guest_password,
	autoassign_start_date, autoassign_end_date, autoassign_latitude, autoassign_longitude, autoassign_radius
) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateAlbumParams struct {
	Owner               int64
	Name                string
	UrlSlug             string
	Shared              int64
	ReadonlySecret      string
	ReadwriteSecret     string
	GuestPassword       sql.NullString
	AutoassignStartDate sql.NullInt64
	AutoassignEndDate   sql.NullInt64
	AutoassignLatitude  sql.NullFloat64
	AutoassignLongitude sql.NullFloat64
	AutoassignRadius    sql.NullFloat64
}

// ----------
// ALBUMS --
// ----------
func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) error {
	_, err := q.db.ExecContext(ctx, createAlbum,
		arg.Owner,
		arg.Name,
		arg.UrlSlug,
		arg.Shared,
		arg.ReadonlySecret,
		arg.ReadwriteSecret,
		arg.GuestPassword,
		arg.AutoassignStartDate,
		arg.AutoassignEndDate,
		arg.AutoassignLatitude,
		arg.AutoassignLongitude,
		arg.AutoassignRadius,
	)
	return err
}

const createAsset = `-- name: CreateAsset :exec
INSERT OR IGNORE INTO asset (
	sha256, created_at, original_filename, type,
	thumbnail, thumbhash,
	description, date_taken, latitude, longitude )
VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateAssetParams struct {
	Sha256           []byte
	CreatedAt        int64
	OriginalFilename string
	Type             string
	Thumbnail        []byte
	Thumbhash        []byte
	Description      sql.NullString
	DateTaken        sql.NullInt64
	Latitude         sql.NullFloat64
	Longitude        sql.NullFloat64
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) error {
	_, err := q.db.ExecContext(ctx, createAsset,
		arg.Sha256,
		arg.CreatedAt,
		arg.OriginalFilename,
		arg.Type,
		arg.Thumbnail,
		arg.Thumbhash,
		arg.Description,
		arg.DateTaken,
		arg.Latitude,
		arg.Longitude,
	)
	return err
}

const createPhoto = `-- name: CreatePhoto :one

INSERT INTO photo ( owner, created_at, primary_asset )
VALUES( ?, ?, ? )
RETURNING id
`

type CreatePhotoParams struct {
	Owner        sql.NullInt64
	CreatedAt    int64
	PrimaryAsset []byte
}

// ----------
// PHOTOS --
// ----------
func (q *Queries) CreatePhoto(ctx context.Context, arg CreatePhotoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createPhoto, arg.Owner, arg.CreatedAt, arg.PrimaryAsset)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO user ( username, password, needs_to_reset_password, cookie ) VALUES ( ?, ?, 1, ? )
RETURNING id
`

type CreateUserParams struct {
	Username string
	Password string
	Cookie   []byte
}

// ---------
// USERS --
// ---------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Password, arg.Cookie)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteAlbum = `-- name: DeleteAlbum :exec
UPDATE album SET delete_at = ? WHERE owner = ? AND url_slug = ?
`

type DeleteAlbumParams struct {
	DeleteAt sql.NullInt64
	Owner    int64
	UrlSlug  string
}

func (q *Queries) DeleteAlbum(ctx context.Context, arg DeleteAlbumParams) error {
	_, err := q.db.ExecContext(ctx, deleteAlbum, arg.DeleteAt, arg.Owner, arg.UrlSlug)
	return err
}

const deleteUnusedAvatars = `-- name: DeleteUnusedAvatars :exec
DELETE FROM avatar WHERE NOT EXISTS( SELECT 1 FROM user WHERE user.avatar = avatar.sha256 )
`

func (q *Queries) DeleteUnusedAvatars(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteUnusedAvatars)
	return err
}

const disableUser = `-- name: DisableUser :exec
UPDATE user SET enabled = 0 WHERE username = ?
`

func (q *Queries) DisableUser(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, disableUser, username)
	return err
}

const enableUser = `-- name: EnableUser :exec
UPDATE user SET enabled = 1 WHERE username = ?
`

func (q *Queries) EnableUser(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, enableUser, username)
	return err
}

const getAlbumAssets = `-- name: GetAlbumAssets :many
SELECT asset.sha256 AS asset, asset.type FROM asset
INNER JOIN photo_asset ON asset.sha256 = photo_asset.asset_id
INNER JOIN photo ON photo.id = photo_asset.photo_id
INNER JOIN album_photo ON photo.id = album_photo.photo_id
INNER JOIN album ON album.id = album_photo.album_id
WHERE album.id = ? AND (
	( ? OR photo.primary_asset = asset.sha256 )
	OR ( ? AND asset.type = "raw" )
)
`

type GetAlbumAssetsParams struct {
	ID                int64
	IncludeEverything interface{}
	IncludeRaws       interface{}
}

type GetAlbumAssetsRow struct {
	Asset []byte
	Type  string
}

func (q *Queries) GetAlbumAssets(ctx context.Context, arg GetAlbumAssetsParams) ([]GetAlbumAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumAssets, arg.ID, arg.IncludeEverything, arg.IncludeRaws)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumAssetsRow
	for rows.Next() {
		var i GetAlbumAssetsRow
		if err := rows.Scan(&i.Asset, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumAutoassignRules = `-- name: GetAlbumAutoassignRules :many
SELECT
	id AS album_id,
	autoassign_start_date AS start_date,
	autoassign_end_date AS end_date,
	autoassign_latitude AS latitude,
	autoassign_longitude AS longitude,
	autoassign_radius AS radius
FROM album WHERE ? BETWEEN autoassign_start_date AND autoassign_end_date
`

type GetAlbumAutoassignRulesRow struct {
	AlbumID   int64
	StartDate sql.NullInt64
	EndDate   sql.NullInt64
	Latitude  sql.NullFloat64
	Longitude sql.NullFloat64
	Radius    sql.NullFloat64
}

func (q *Queries) GetAlbumAutoassignRules(ctx context.Context) ([]GetAlbumAutoassignRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumAutoassignRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumAutoassignRulesRow
	for rows.Next() {
		var i GetAlbumAutoassignRulesRow
		if err := rows.Scan(
			&i.AlbumID,
			&i.StartDate,
			&i.EndDate,
			&i.Latitude,
			&i.Longitude,
			&i.Radius,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumByURL = `-- name: GetAlbumByURL :one
SELECT
	album.id, album.owner, url_slug, user.username AS owner_username,
	album.name, shared, readonly_secret, readwrite_secret, guest_password,
	album_key_asset.sha256 AS key_photo_sha256
FROM album
LEFT OUTER JOIN album_key_asset ON album.id = album_key_asset.id
INNER JOIN user ON album.owner = user.id
LEFT OUTER JOIN album_photo ON album_photo.album_id = album.id
LEFT OUTER JOIN photo ON album_photo.photo_id = photo.id
LEFT OUTER JOIN photo_primary_asset ON photo.id = photo_primary_asset.photo_id
WHERE user.username = ? AND url_slug = ? AND album.delete_at IS NULL
`

type GetAlbumByURLParams struct {
	Owner   string
	UrlSlug string
}

type GetAlbumByURLRow struct {
	ID              int64
	Owner           int64
	UrlSlug         string
	OwnerUsername   string
	Name            string
	Shared          int64
	ReadonlySecret  string
	ReadwriteSecret string
	GuestPassword   sql.NullString
	KeyPhotoSha256  []byte
}

func (q *Queries) GetAlbumByURL(ctx context.Context, arg GetAlbumByURLParams) (GetAlbumByURLRow, error) {
	row := q.db.QueryRowContext(ctx, getAlbumByURL, arg.Owner, arg.UrlSlug)
	var i GetAlbumByURLRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.UrlSlug,
		&i.OwnerUsername,
		&i.Name,
		&i.Shared,
		&i.ReadonlySecret,
		&i.ReadwriteSecret,
		&i.GuestPassword,
		&i.KeyPhotoSha256,
	)
	return i, err
}

const getAlbumDateRange = `-- name: GetAlbumDateRange :one
SELECT
	MIN( photo_primary_asset.date_taken ) AS oldest_photo,
	MAX( photo_primary_asset.date_taken ) AS newest_photo
FROM album
LEFT OUTER JOIN album_key_asset ON album.id = album_key_asset.id
INNER JOIN user ON album.owner = user.id
LEFT OUTER JOIN album_photo ON album_photo.album_id = album.id
LEFT OUTER JOIN photo ON album_photo.photo_id = photo.id
LEFT OUTER JOIN photo_primary_asset ON photo.id = photo_primary_asset.photo_id
WHERE album.id = ? AND album.delete_at IS NULL
`

type GetAlbumDateRangeRow struct {
	OldestPhoto interface{}
	NewestPhoto interface{}
}

func (q *Queries) GetAlbumDateRange(ctx context.Context, id int64) (GetAlbumDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getAlbumDateRange, id)
	var i GetAlbumDateRangeRow
	err := row.Scan(&i.OldestPhoto, &i.NewestPhoto)
	return i, err
}

const getAlbumOwner = `-- name: GetAlbumOwner :one
SELECT owner FROM album WHERE id = ?
`

func (q *Queries) GetAlbumOwner(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAlbumOwner, id)
	var owner int64
	err := row.Scan(&owner)
	return owner, err
}

const getAlbumPhotos = `-- name: GetAlbumPhotos :many
SELECT photo.id, photo_primary_asset.sha256, photo_primary_asset.thumbhash
FROM photo
INNER JOIN album_photo ON album_photo.photo_id = photo.id
INNER JOIN photo_primary_asset ON photo.id = photo_primary_asset.photo_id
WHERE album_photo.album_id = ?
ORDER BY photo_primary_asset.date_taken ASC
`

type GetAlbumPhotosRow struct {
	ID        int64
	Sha256    []byte
	Thumbhash []byte
}

func (q *Queries) GetAlbumPhotos(ctx context.Context, albumID int64) ([]GetAlbumPhotosRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumPhotos, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumPhotosRow
	for rows.Next() {
		var i GetAlbumPhotosRow
		if err := rows.Scan(&i.ID, &i.Sha256, &i.Thumbhash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlbumsForUser = `-- name: GetAlbumsForUser :many
SELECT album.name, album.url_slug, user.username as owner, album_key_asset.sha256 AS key_photo_sha256 FROM album
LEFT OUTER JOIN album_key_asset ON album.id = album_key_asset.id
INNER JOIN user ON album.owner = user.id
WHERE ( album.shared OR album.owner = ? ) AND album.delete_at IS NULL
ORDER BY album.name
`

type GetAlbumsForUserRow struct {
	Name           string
	UrlSlug        string
	Owner          string
	KeyPhotoSha256 []byte
}

func (q *Queries) GetAlbumsForUser(ctx context.Context, owner int64) ([]GetAlbumsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumsForUser, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlbumsForUserRow
	for rows.Next() {
		var i GetAlbumsForUserRow
		if err := rows.Scan(
			&i.Name,
			&i.UrlSlug,
			&i.Owner,
			&i.KeyPhotoSha256,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnAssetThatNeedsANewAIDescription = `-- name: GetAnAssetThatNeedsANewAIDescription :one
SELECT sha256, thumbnail FROM asset
LEFT JOIN ai_description ON sha256 = asset_id
WHERE generator IS NULL OR generator != ?
ORDER BY generator ASC NULLS FIRST
LIMIT 1
`

type GetAnAssetThatNeedsANewAIDescriptionRow struct {
	Sha256    []byte
	Thumbnail []byte
}

func (q *Queries) GetAnAssetThatNeedsANewAIDescription(ctx context.Context, generator int64) (GetAnAssetThatNeedsANewAIDescriptionRow, error) {
	row := q.db.QueryRowContext(ctx, getAnAssetThatNeedsANewAIDescription, generator)
	var i GetAnAssetThatNeedsANewAIDescriptionRow
	err := row.Scan(&i.Sha256, &i.Thumbnail)
	return i, err
}

const getAssetGuestMetadata = `-- name: GetAssetGuestMetadata :one
SELECT type, original_filename, EXISTS(
	SELECT 1 FROM photo_asset
	INNER JOIN photo ON photo.id = photo_asset.photo_id
	INNER JOIN album_photo ON album_photo.photo_id = photo.id
	INNER JOIN album ON album.id = album_photo.album_id
	INNER JOIN user ON user.id = album.owner
	WHERE user.username = ? AND album.url_slug = ? AND ( album.readonly_secret = ? OR album.readwrite_secret = ? ) AND ( album.guest_password IS NULL OR album.guest_password = ? )
) AS has_permission
FROM asset WHERE sha256 = ?
`

type GetAssetGuestMetadataParams struct {
	Owner           string
	UrlSlug         string
	ReadonlySecret  string
	ReadwriteSecret string
	GuestPassword   sql.NullString
	Sha256          []byte
}

type GetAssetGuestMetadataRow struct {
	Type             string
	OriginalFilename string
	HasPermission    int64
}

func (q *Queries) GetAssetGuestMetadata(ctx context.Context, arg GetAssetGuestMetadataParams) (GetAssetGuestMetadataRow, error) {
	row := q.db.QueryRowContext(ctx, getAssetGuestMetadata,
		arg.Owner,
		arg.UrlSlug,
		arg.ReadonlySecret,
		arg.ReadwriteSecret,
		arg.GuestPassword,
		arg.Sha256,
	)
	var i GetAssetGuestMetadataRow
	err := row.Scan(&i.Type, &i.OriginalFilename, &i.HasPermission)
	return i, err
}

const getAssetGuestThumbnail = `-- name: GetAssetGuestThumbnail :one
SELECT thumbnail, original_filename, EXISTS(
	SELECT 1 FROM photo_asset
	INNER JOIN photo ON photo.id = photo_asset.photo_id
	INNER JOIN album_photo ON album_photo.photo_id = photo.id
	INNER JOIN album ON album.id = album_photo.album_id
	INNER JOIN user ON user.id = album.owner
	WHERE user.username = ? AND album.url_slug = ? AND ( album.readonly_secret = ? OR album.readwrite_secret = ? ) AND ( album.guest_password IS NULL OR album.guest_password = ? )
) AS has_permission
FROM asset WHERE sha256 = ?
`

type GetAssetGuestThumbnailParams struct {
	Owner           string
	UrlSlug         string
	ReadonlySecret  string
	ReadwriteSecret string
	GuestPassword   sql.NullString
	Sha256          []byte
}

type GetAssetGuestThumbnailRow struct {
	Thumbnail        []byte
	OriginalFilename string
	HasPermission    int64
}

func (q *Queries) GetAssetGuestThumbnail(ctx context.Context, arg GetAssetGuestThumbnailParams) (GetAssetGuestThumbnailRow, error) {
	row := q.db.QueryRowContext(ctx, getAssetGuestThumbnail,
		arg.Owner,
		arg.UrlSlug,
		arg.ReadonlySecret,
		arg.ReadwriteSecret,
		arg.GuestPassword,
		arg.Sha256,
	)
	var i GetAssetGuestThumbnailRow
	err := row.Scan(&i.Thumbnail, &i.OriginalFilename, &i.HasPermission)
	return i, err
}

const getAssetMetadata = `-- name: GetAssetMetadata :one
SELECT type, original_filename, EXISTS(
	SELECT 1 FROM photo_asset
	INNER JOIN photo ON photo.id = photo_asset.photo_id
	INNER JOIN album_photo ON album_photo.photo_id = photo.id
	INNER JOIN album ON album.id = album_photo.album_id
	-- TODO: this is failing when the photo is owned but not in an album
	WHERE photo_asset.asset_id = ? AND ( photo.owner = ? OR album.owner = ? OR album.shared )
) AS has_permission
FROM asset WHERE sha256 = ?
`

type GetAssetMetadataParams struct {
	AssetID []byte
	Owner   sql.NullInt64
	Owner_2 int64
	Sha256  []byte
}

type GetAssetMetadataRow struct {
	Type             string
	OriginalFilename string
	HasPermission    int64
}

func (q *Queries) GetAssetMetadata(ctx context.Context, arg GetAssetMetadataParams) (GetAssetMetadataRow, error) {
	row := q.db.QueryRowContext(ctx, getAssetMetadata,
		arg.AssetID,
		arg.Owner,
		arg.Owner_2,
		arg.Sha256,
	)
	var i GetAssetMetadataRow
	err := row.Scan(&i.Type, &i.OriginalFilename, &i.HasPermission)
	return i, err
}

const getAssetPhotos = `-- name: GetAssetPhotos :many
SELECT photo.id FROM photo, photo_asset
WHERE photo_asset.asset_id = ? AND photo.owner IS ? AND photo.id = photo_asset.photo_id
`

type GetAssetPhotosParams struct {
	AssetID []byte
	Owner   sql.NullInt64
}

func (q *Queries) GetAssetPhotos(ctx context.Context, arg GetAssetPhotosParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getAssetPhotos, arg.AssetID, arg.Owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetThumbnail = `-- name: GetAssetThumbnail :one
SELECT thumbnail, original_filename FROM asset WHERE sha256 = ?
`

type GetAssetThumbnailRow struct {
	Thumbnail        []byte
	OriginalFilename string
}

func (q *Queries) GetAssetThumbnail(ctx context.Context, sha256 []byte) (GetAssetThumbnailRow, error) {
	row := q.db.QueryRowContext(ctx, getAssetThumbnail, sha256)
	var i GetAssetThumbnailRow
	err := row.Scan(&i.Thumbnail, &i.OriginalFilename)
	return i, err
}

const getAvatar = `-- name: GetAvatar :one
SELECT avatar FROM avatar WHERE sha256 = ?
`

func (q *Queries) GetAvatar(ctx context.Context, sha256 []byte) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getAvatar, sha256)
	var avatar []byte
	err := row.Scan(&avatar)
	return avatar, err
}

const getPhoto = `-- name: GetPhoto :one
SELECT asset.sha256, asset.type, asset.original_filename FROM photo, asset
WHERE photo.id = ? AND asset.sha256 = IFNULL( photo.primary_asset,
	( SELECT sha256 FROM asset
	INNER JOIN photo_asset ON photo_asset.asset_id = asset.sha256
	WHERE photo_asset.photo_id = photo.id AND asset.type != "raw"
	ORDER BY asset.created_at DESC LIMIT 1 ) )
`

type GetPhotoRow struct {
	Sha256           []byte
	Type             string
	OriginalFilename string
}

func (q *Queries) GetPhoto(ctx context.Context, id int64) (GetPhotoRow, error) {
	row := q.db.QueryRowContext(ctx, getPhoto, id)
	var i GetPhotoRow
	err := row.Scan(&i.Sha256, &i.Type, &i.OriginalFilename)
	return i, err
}

const getPhotoAlbums = `-- name: GetPhotoAlbums :many
SELECT name, url_slug FROM album
INNER JOIN album_photo ON album_photo.album_id = album.id
WHERE album_photo.photo_id = ?
ORDER BY album.name
`

type GetPhotoAlbumsRow struct {
	Name    string
	UrlSlug string
}

func (q *Queries) GetPhotoAlbums(ctx context.Context, photoID int64) ([]GetPhotoAlbumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPhotoAlbums, photoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhotoAlbumsRow
	for rows.Next() {
		var i GetPhotoAlbumsRow
		if err := rows.Scan(&i.Name, &i.UrlSlug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoAssets = `-- name: GetPhotoAssets :many
SELECT asset.sha256 AS asset, asset.type, photo.owner = ? AS owned
FROM asset
INNER JOIN photo_asset ON asset.sha256 = photo_asset.asset_id
INNER JOIN photo ON photo.id = photo_asset.photo_id
WHERE photo.id = ? AND (
	( ? OR photo.primary_asset = asset.sha256 )
	OR ( ? AND asset.type = "raw" )
)
`

type GetPhotoAssetsParams struct {
	Owner             sql.NullInt64
	ID                int64
	IncludeEverything interface{}
	IncludeRaws       interface{}
}

type GetPhotoAssetsRow struct {
	Asset []byte
	Type  string
	Owned bool
}

func (q *Queries) GetPhotoAssets(ctx context.Context, arg GetPhotoAssetsParams) ([]GetPhotoAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPhotoAssets,
		arg.Owner,
		arg.ID,
		arg.IncludeEverything,
		arg.IncludeRaws,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhotoAssetsRow
	for rows.Next() {
		var i GetPhotoAssetsRow
		if err := rows.Scan(&i.Asset, &i.Type, &i.Owned); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoAssetsForGuest = `-- name: GetPhotoAssetsForGuest :many
SELECT asset.sha256 AS asset, asset.type, EXISTS(
	SELECT 1 FROM album_photo
	WHERE album_photo.photo_id = ? AND album_photo.album_id = ?
) AS has_permission
FROM asset
INNER JOIN photo_asset ON asset.sha256 = photo_asset.asset_id
INNER JOIN photo ON photo.id = photo_asset.photo_id
WHERE photo.id = ? AND (
	( ? OR photo.primary_asset = asset.sha256 )
	OR ( ? AND asset.type = "raw" )
)
`

type GetPhotoAssetsForGuestParams struct {
	PhotoID           int64
	AlbumID           int64
	ID                int64
	IncludeEverything interface{}
	IncludeRaws       interface{}
}

type GetPhotoAssetsForGuestRow struct {
	Asset         []byte
	Type          string
	HasPermission int64
}

func (q *Queries) GetPhotoAssetsForGuest(ctx context.Context, arg GetPhotoAssetsForGuestParams) ([]GetPhotoAssetsForGuestRow, error) {
	rows, err := q.db.QueryContext(ctx, getPhotoAssetsForGuest,
		arg.PhotoID,
		arg.AlbumID,
		arg.ID,
		arg.IncludeEverything,
		arg.IncludeRaws,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhotoAssetsForGuestRow
	for rows.Next() {
		var i GetPhotoAssetsForGuestRow
		if err := rows.Scan(&i.Asset, &i.Type, &i.HasPermission); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoOwner = `-- name: GetPhotoOwner :one
SELECT owner FROM photo WHERE id = ?
`

func (q *Queries) GetPhotoOwner(ctx context.Context, id int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, getPhotoOwner, id)
	var owner sql.NullInt64
	err := row.Scan(&owner)
	return owner, err
}

const getPhotoOwnerName = `-- name: GetPhotoOwnerName :one
SELECT user.username
FROM photo
INNER JOIN user ON photo.owner = user.id
WHERE photo.id = ?
`

func (q *Queries) GetPhotoOwnerName(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getPhotoOwnerName, id)
	var username string
	err := row.Scan(&username)
	return username, err
}

const getPhotoVariants = `-- name: GetPhotoVariants :many
SELECT
	sha256,
	original_filename,
	type,
	thumbhash,
	description,
	date_taken,
	latitude,
	longitude
FROM asset
INNER JOIN photo_asset ON asset.sha256 = photo_asset.asset_id
WHERE photo_asset.photo_id = ?
`

type GetPhotoVariantsRow struct {
	Sha256           []byte
	OriginalFilename string
	Type             string
	Thumbhash        []byte
	Description      sql.NullString
	DateTaken        sql.NullInt64
	Latitude         sql.NullFloat64
	Longitude        sql.NullFloat64
}

func (q *Queries) GetPhotoVariants(ctx context.Context, photoID int64) ([]GetPhotoVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPhotoVariants, photoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhotoVariantsRow
	for rows.Next() {
		var i GetPhotoVariantsRow
		if err := rows.Scan(
			&i.Sha256,
			&i.OriginalFilename,
			&i.Type,
			&i.Thumbhash,
			&i.Description,
			&i.DateTaken,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthDetails = `-- name: GetUserAuthDetails :one
SELECT id, password, needs_to_reset_password, enabled, cookie FROM user WHERE username = ?
`

type GetUserAuthDetailsRow struct {
	ID                   int64
	Password             string
	NeedsToResetPassword int64
	Enabled              int64
	Cookie               []byte
}

func (q *Queries) GetUserAuthDetails(ctx context.Context, username string) (GetUserAuthDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthDetails, username)
	var i GetUserAuthDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Password,
		&i.NeedsToResetPassword,
		&i.Enabled,
		&i.Cookie,
	)
	return i, err
}

const getUserPassword = `-- name: GetUserPassword :one
SELECT password FROM user WHERE id = ?
`

func (q *Queries) GetUserPassword(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserPassword, id)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getUserPhotos = `-- name: GetUserPhotos :many
SELECT photo.id, photo_primary_asset.sha256, photo_primary_asset.thumbhash
FROM photo
INNER JOIN photo_primary_asset ON photo.id = photo_primary_asset.photo_id
WHERE owner = ? ORDER BY photo_primary_asset.date_taken DESC
`

type GetUserPhotosRow struct {
	ID        int64
	Sha256    []byte
	Thumbhash []byte
}

func (q *Queries) GetUserPhotos(ctx context.Context, owner sql.NullInt64) ([]GetUserPhotosRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPhotos, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPhotosRow
	for rows.Next() {
		var i GetUserPhotosRow
		if err := rows.Scan(&i.ID, &i.Sha256, &i.Thumbhash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT username, avatar FROM user WHERE enabled = 1 ORDER BY username
`

type GetUsersRow struct {
	Username string
	Avatar   []byte
}

func (q *Queries) GetUsers(ctx context.Context) ([]GetUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(&i.Username, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isAlbumURLInUse = `-- name: IsAlbumURLInUse :one
SELECT EXISTS ( SELECT 1 FROM album WHERE owner = ? AND url_slug = ? )
`

type IsAlbumURLInUseParams struct {
	Owner   int64
	UrlSlug string
}

func (q *Queries) IsAlbumURLInUse(ctx context.Context, arg IsAlbumURLInUseParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isAlbumURLInUse, arg.Owner, arg.UrlSlug)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const purgeDeletedAlbums = `-- name: PurgeDeletedAlbums :exec
DELETE FROM album WHERE delete_at IS NOT NULL AND delete_at < ?
`

func (q *Queries) PurgeDeletedAlbums(ctx context.Context, deleteAt sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, purgeDeletedAlbums, deleteAt)
	return err
}

const removeMyPhotoFromAlbum = `-- name: RemoveMyPhotoFromAlbum :exec
DELETE FROM album_photo
WHERE photo_id = ? AND album_id = ? AND EXISTS (
	SELECT NULL FROM photo
	WHERE id = photo_id AND owner = ?
)
`

type RemoveMyPhotoFromAlbumParams struct {
	PhotoID int64
	AlbumID int64
	Owner   sql.NullInt64
}

func (q *Queries) RemoveMyPhotoFromAlbum(ctx context.Context, arg RemoveMyPhotoFromAlbumParams) error {
	_, err := q.db.ExecContext(ctx, removeMyPhotoFromAlbum, arg.PhotoID, arg.AlbumID, arg.Owner)
	return err
}

const removePhotoFromAlbum = `-- name: RemovePhotoFromAlbum :exec
DELETE FROM album_photo WHERE album_id = ? AND photo_id = ?
`

type RemovePhotoFromAlbumParams struct {
	AlbumID int64
	PhotoID int64
}

func (q *Queries) RemovePhotoFromAlbum(ctx context.Context, arg RemovePhotoFromAlbumParams) error {
	_, err := q.db.ExecContext(ctx, removePhotoFromAlbum, arg.AlbumID, arg.PhotoID)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE user SET password = ?, needs_to_reset_password = 1, cookie = ? WHERE username = ?
`

type ResetUserPasswordParams struct {
	Password string
	Cookie   []byte
	Username string
}

func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, resetUserPassword, arg.Password, arg.Cookie, arg.Username)
	return err
}

const restoreDeletedAlbum = `-- name: RestoreDeletedAlbum :exec
UPDATE album SET delete_at = NULL WHERE owner = ? AND url_slug = ?
`

type RestoreDeletedAlbumParams struct {
	Owner   int64
	UrlSlug string
}

func (q *Queries) RestoreDeletedAlbum(ctx context.Context, arg RestoreDeletedAlbumParams) error {
	_, err := q.db.ExecContext(ctx, restoreDeletedAlbum, arg.Owner, arg.UrlSlug)
	return err
}

const setAlbumIsShared = `-- name: SetAlbumIsShared :exec
UPDATE album SET shared = ?, guest_password = ? WHERE id = ? AND owner = ?
`

type SetAlbumIsSharedParams struct {
	Shared        int64
	GuestPassword sql.NullString
	ID            int64
	Owner         int64
}

func (q *Queries) SetAlbumIsShared(ctx context.Context, arg SetAlbumIsSharedParams) error {
	_, err := q.db.ExecContext(ctx, setAlbumIsShared,
		arg.Shared,
		arg.GuestPassword,
		arg.ID,
		arg.Owner,
	)
	return err
}

const setAlbumSettings = `-- name: SetAlbumSettings :exec
UPDATE album SET name = ?, url_slug = ? WHERE id = ? AND owner = ?
`

type SetAlbumSettingsParams struct {
	Name    string
	UrlSlug string
	ID      int64
	Owner   int64
}

func (q *Queries) SetAlbumSettings(ctx context.Context, arg SetAlbumSettingsParams) error {
	_, err := q.db.ExecContext(ctx, setAlbumSettings,
		arg.Name,
		arg.UrlSlug,
		arg.ID,
		arg.Owner,
	)
	return err
}

const setAssetAIDescription = `-- name: SetAssetAIDescription :exec

INSERT OR REPLACE INTO ai_description ( asset_id, generator, description ) VALUES ( ?, ?, ? )
`

type SetAssetAIDescriptionParams struct {
	AssetID     []byte
	Generator   int64
	Description string
}

// --------------
// AI TAGGING --
// --------------
func (q *Queries) SetAssetAIDescription(ctx context.Context, arg SetAssetAIDescriptionParams) error {
	_, err := q.db.ExecContext(ctx, setAssetAIDescription, arg.AssetID, arg.Generator, arg.Description)
	return err
}

const setUserAvatar = `-- name: SetUserAvatar :exec
UPDATE user SET avatar = ? WHERE id = ?
`

type SetUserAvatarParams struct {
	Avatar []byte
	ID     int64
}

func (q *Queries) SetUserAvatar(ctx context.Context, arg SetUserAvatarParams) error {
	_, err := q.db.ExecContext(ctx, setUserAvatar, arg.Avatar, arg.ID)
	return err
}

const setUserPassword = `-- name: SetUserPassword :exec
UPDATE user SET password = ? WHERE id = ?
`

type SetUserPasswordParams struct {
	Password string
	ID       int64
}

func (q *Queries) SetUserPassword(ctx context.Context, arg SetUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, setUserPassword, arg.Password, arg.ID)
	return err
}

const setUserPasswordIfMustReset = `-- name: SetUserPasswordIfMustReset :one
UPDATE user SET password = ?, needs_to_reset_password = 0 WHERE id = ? AND needs_to_reset_password = 1 RETURNING 1
`

type SetUserPasswordIfMustResetParams struct {
	Password string
	ID       int64
}

func (q *Queries) SetUserPasswordIfMustReset(ctx context.Context, arg SetUserPasswordIfMustResetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, setUserPasswordIfMustReset, arg.Password, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
